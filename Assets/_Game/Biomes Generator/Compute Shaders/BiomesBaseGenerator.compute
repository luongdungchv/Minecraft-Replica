// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GenerateBase
#pragma kernel ClearTempMap
#pragma kernel GenerateZoomLevel
#pragma kernel CopyIntMapToFloatMap
#pragma kernel TransferTemp
//#pragma kernel GenerateFinalPhase
#pragma kernel TransferTempNoCut
#pragma kernel RemoveIsolated
#pragma kernel RemoveOceans
#pragma kernel AddIslands
#pragma kernel TransferTempToSec

#include "Assets/Shader Headers/Random.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float> BiomeMap, tempMap, secondTempMap;
RWTexture2D<int> tempMapInt;

float seed, zoomLevel, occupiedSize;
int2 offset, chunkSize, corner;

float2 dirs[4];

[numthreads(4,4,1)]
void GenerateBase(int3 id : SV_DispatchThreadID)
{
    int2 baseOffset = offset / 4096;
    int2 cellPosWS = id.xy + baseOffset;
    float randomValue = rand2dTo1d(float2(cellPosWS.x + seed, cellPosWS.y + seed));
    BiomeMap[id.xy] = step(0.85, randomValue);
    //float originalCellVal = BiomeMap[id.xy];
    //tempMap[id.xy] = step(0.6, randomValue);
    // BiomeMap[id.xy] = randomValue;
}
[numthreads(8, 8, 1)]
void GenerateZoomLevel(int3 id: SV_DispatchThreadID){
    //if(id.x < 3 || id.y < 3 || id.x == 7 || id.y == 7) return;
    // int cellSize = 4096 / pow(2, zoomLevel - 1);
    // int2 baseOffset = offset / cellSize;
    // int2 parentOffset = offset / (4096 / pow(2, zoomLevel - 2));

    float originalCellVal = BiomeMap[id.xy / 2];
    //tempMap[id.xy] = (int)(originalCellVal * 1000);
    secondTempMap[id.xy] = originalCellVal;
    // if(originalCellVal == 0) return;

    // for(int i = 0; i < 4; i++){
    //     int2 adjID = id.xy + int2((int)dirs[i].x, (int)dirs[i].y);
    //     if(adjID.x < 0 || adjID.y < 0) continue;
    //     if(BiomeMap[adjID.xy / 2] > 0) continue;

    //     float randomVal = rand1dTo1d(seed + parentOffset.x * 4 + parentOffset.y + adjID.x * 2 + adjID.y + i);
    //     //InterlockedCompareStore(tempMapInt[adjID.xy], 0, step(0.8, randomVal) * 1000);
    //     //tempMapInt[adjID.xy] = step(0.8, randomVal) * 1000;
    //     if(tempMap[adjID.xy] == 0)
    //         tempMap[adjID.xy] = step(0.8, randomVal);
    // }
    // float originalCellVal = BiomeMap[id.xy];
    // tempMap[id.xy] = (originalCellVal);
}

[numthreads(8, 8, 1)]
void AddIslands(int3 id: SV_DispatchThreadID){
    int cellSize = 4096 / pow(2, zoomLevel - 1);
    int2 baseOffset = offset / cellSize;
    int2 parentOffset = offset / (4096 / pow(2, zoomLevel - 2));
    float originalCellVal = secondTempMap[id.xy];
    tempMap[id.xy] = originalCellVal;
    
    if(originalCellVal == 0) return;
    
    for(int i = 0; i < 4; i++){
        int2 adjID = id.xy + int2((int)dirs[i].x, (int)dirs[i].y);
        if(adjID.x < 0 || adjID.y < 0) continue;
        if(secondTempMap[adjID.xy] > 0) continue;
        
        int2 adjWS = adjID + baseOffset;

        float randomVal = rand2dTo1d(adjWS.x + seed / zoomLevel, adjWS.y + seed % zoomLevel);
        //InterlockedCompareStore(tempMapInt[adjID.xy], 0, step(0.8, randomVal) * 1000);
        //tempMapInt[adjID.xy] = step(0.8, randomVal) * 1000;
        if(tempMap[adjID.xy] == 0){
            tempMap[adjID.xy] = step(0.5, randomVal);
        }
    }
}

[numthreads(8, 8, 1)]
void ClearTempMap(int3 id: SV_DispatchThreadID){
    tempMapInt[id.xy] = 0;
}

[numthreads(8, 8, 1)]
void TransferTempToSec(int3 id: SV_DispatchThreadID){
    secondTempMap[id.xy] = tempMap[id.xy];
}

[numthreads(8, 8, 1)]
void CopyIntMapToFloatMap(int3 id: SV_DispatchThreadID){
    tempMap[id.xy] = (float)tempMapInt[id.xy] / 1000;
}

[numthreads(8, 8, 1)]
void TransferTemp(int3 id: SV_DispatchThreadID){
    int cellSize = 4096 / pow(2, zoomLevel - 1);
    int2 baseOffset = offset / cellSize;
    int2 parentOffset = offset / (4096 / pow(2, zoomLevel - 2));
    int2 cellIndex = baseOffset - parentOffset * 2;
    int2 cellPosWS = id.xy + baseOffset;
    
    if(id.x < 2 + cellIndex.x || id.y < 2 + cellIndex.y || id.x >= 6 + cellIndex.x || id.y >= 6 + cellIndex.y) return;
    
    
    int2 biomeID = id.xy - cellIndex - int2(2, 2);
    float value = tempMap[id.xy];
    if(value > 0){
        // float prob = 0;
        // for(int i = 0; i < 4; i++){
        //     int2 adjID = id.xy + int2((int)dirs[i].x, (int)dirs[i].y);
        //     if(adjID.x < 0 || adjID.y < 0 || adjID.x >= 8 || adjID.y >= 8) continue;
        //     if(tempMap[adjID.xy] == 0) prob += 0.1;
        // }
        float sqrtSeed = sqrt(seed);
        float random = rand2dTo1d(float2((float)cellPosWS.x + sqrtSeed, (float)cellPosWS.y - sqrtSeed / 2));
        //value = step(0.1, random);
    }
    else{   
        float random = rand2dTo1d(float2((float)cellPosWS.x / sqrt(seed), (float)cellPosWS.y + sin(seed) * 5));
        //float random = rand2dTo1d(float2(seed + id.x, id.y + zoomLevel));
        //value = step(0.93, random);
    }
    BiomeMap[biomeID.xy] = value; 
}

// [numthreads(8, 8, 1)]
// void GenerateFinalPhase(int3 id: SV_DispatchThreadID){
//     float originalCellVal = BiomeMap[id.xy / 2];
    
//     int cellSize = 4096 / pow(2, zoomLevel - 1);
//     int2 baseOffset = offset / cellSize;
//     int2 cellPosWS = id.xy + 

//     tempMap[id.xy] = originalCellVal;
//     if(originalCellVal == 0) return;

//     for(int i = 0; i < 4; i++){
//         int2 adjID = id.xy + int2((int)dirs[i].x, (int)dirs[i].y);
//         if(adjID.x < 0 || adjID.y < 0) continue;
//         if(BiomeMap[adjID.xy / 2] > 0) continue;

//         float randomVal = rand1dTo1d(seed + zoomLevel * 9 + offset.x * 4 + offset.y + adjID.x * 2 + adjID.y + i);
//         if(tempMap[adjID.xy] == 0)
//             tempMap[adjID.xy] = step(0.8, randomVal);
//     }
// }

[numthreads(8, 8, 1)]
void TransferTempNoCut(int3 id: SV_DispatchThreadID){
    int size = pow(2, zoomLevel);
    if(id.x >= size || id.y >= size) return;
    int2 biomeID = id.xy;
    float value = tempMap[id.xy];
    int2 cellPosWS = id.xy + offset / (4096 / pow(2, zoomLevel - 1));
    if(value > 0){
        float prob = 0;
        for(int i = 0; i < 4; i++){
            int2 adjID = id.xy + int2((int)dirs[i].x, (int)dirs[i].y);
            if(adjID.x < 0 || adjID.y < 0 || adjID.x >= size || adjID.y >= size) continue;
            if(tempMap[adjID.xy] == 0) prob += 0.11;
        }
        if(prob > 0.4) prob = 1.01;
        float sqrtSeed = sqrt(seed);
        float random = rand2dTo1d(float2((float)cellPosWS.x + sqrtSeed, (float)cellPosWS.y - sqrtSeed / 2));
        value = step(prob, random);
        
    }
    else{   
        // float random = rand2dTo1d(seed + id.x * 10 + id.y + zoomLevel * 9);
        //float random = rand2dTo1d(float2(seed + id.x, id.y + zoomLevel));
        //value = step(0.97, random);
    }
    BiomeMap[biomeID.xy] = value; 
}

[numthreads(8, 8, 1)]
void RemoveIsolated(int3 id: SV_DispatchThreadID){
    float value = BiomeMap[id.xy];
    if(value > 0){
        float prob = 0;
        for(int i = 0; i < 4; i++){
            int2 adjID = id.xy + int2((int)dirs[i].x, (int)dirs[i].y);
            if(adjID.x < 0 || adjID.y < 0) continue;
            if(BiomeMap[adjID.xy] == 0) prob += 0.2501;
        }
        float random = rand3dTo1d(float3(seed, offset.x * 3 + offset.y, id.x * 5 + id.y + zoomLevel));
        value = step(prob, random);
        BiomeMap[id.xy] = value;
    }
}

[numthreads(8, 8, 1)]
void RemoveOceans(int3 id: SV_DispatchThreadID){
    int size = 4 * pow(2, zoomLevel - 1);
    if(id.x >= size || id.y >= size) return;
    if(BiomeMap[id.xy] == 0){
        bool createIsland = true;
        for(int i = 0; i < 4; i++){
            int2 adjID = id.xy + dirs[i];
            if(adjID.x < 0 || adjID.y < 0 || adjID.x >= size || adjID.y >= size) continue;
            if(BiomeMap[adjID.xy] > 0){
                createIsland = false;
                break;
            }
        }
        
        float random = rand3dTo1d(float3(seed, offset.x * 3 + offset.y * zoomLevel, id.x * 5 + id.y + zoomLevel));
        BiomeMap[id.xy] = step(0.5, random);
    }
}